<!doctype html>
<html>

<head>
    <meta charset="utf-8">
    <title>Pixi Tile Swap Game</title>
    <script src="scripts/pixi.js"></script>
    <script src="scripts/tween.js"></script>
</head>

<body style="overflow: hidden;">
    <script>
        var app;
        var infoText;
        var tileStartX = 180;
        var tileStartY = 100;
        var tileWidth = 70; //64 tile width + 6px gap
        var numCols = 4;
        var positions = [];
        var numTiles = 16;
        var tiles = [];
        var currentPosition = [];

        window.onload = function () {

            app = new PIXI.Application(window.innerWidth, window.innerHeight, { backgroundColor: 0xf1f3f4 });
            document.body.appendChild(app.view);

            var style = new PIXI.TextStyle({
                fontFamily: 'Arial',
                fontSize: 36,
                fontWeight: 'bold',
                fill: ['#ffffff', '#00ff99'], // gradient
                stroke: '#4a1850',
                strokeThickness: 2
            });

            var infostyle = new PIXI.TextStyle({
                fontFamily: 'Arial',
                fontSize: 18,
                fill: ['#888888', '#444444'] // gradient
            });

            infoText = new PIXI.Text("A pixi.js demo by Monster Brain Games (monsterbraininc.com)", infostyle);
            infoText.x = window.innerWidth / 2;
            infoText.y = window.innerHeight - 40;
            // center the text's anchor point
            infoText.anchor.set(0.5);

            app.stage.addChild(infoText);

            // create a new Sprite from an image path
            var tile = PIXI.Sprite.fromImage('assets/tile.png');

            var startPositions = [12, 0, 3, 6, 1, 4, 2, 7, 15, 13, 9, 14, 10, 8, 5, 11];
            var isTileMoving = false;
            var blankTileIndex = 15;
            var tileTweenTime = 15;

            tileStartX = window.innerWidth / 2 - numCols / 2 * tileWidth;
            tileStartY = 100;

            function debugTextLog(text) {
                document.getElementById("debug").innerHTML = text;
            }

            function onTileClick() {
                if (isTileMoving)
                    return;

                //debugTextLog("Clicked on tile "+this.index +" "+currentPosition[0]);
                var tileIndex = this.index;

                var currentTilePos = currentPosition[tileIndex];
                var blankTilePos = currentPosition[blankTileIndex];

                var tileRowCol = [parseInt(currentTilePos / numCols), currentTilePos % numCols];
                var blankRowCol = [parseInt(blankTilePos / numCols), blankTilePos % numCols];

                console.log({ tileRowCol, blankRowCol });

                // same row
                if (tileRowCol[0] == blankRowCol[0]) {
                    var numMoveTiles = tileRowCol[1] - blankRowCol[1];
                    console.log('numMoveTiles' + numMoveTiles);
                    var left = -1, right = 1;
                    let dir = numMoveTiles < 0 ? right : left;

                    let moveTiles = [];
                    if (dir == right) {
                        console.log('push right');
                        numMoveTiles = -numMoveTiles;
                        for (let i = 0; i < numMoveTiles; i++) {
                            let tileObj = getTileAtPos(i + currentTilePos);
                            moveTiles.push(tileObj);
                            var tweenWithCallback1 = new Tween(tileObj.tile, "position.x", positions[i + currentTilePos + 1].x, tileTweenTime, true);
                            tweenWithCallback1.easing = Tween.outCubic;
                        }

                        let blankTilePosTemp;
                        for (let i = 0; i < moveTiles.length; i++) {
                            const tile = moveTiles[i];
                            if (i == 0) { blankTilePosTemp = currentPosition[tile.index]; } // first tile will be blank at last
                            currentPosition[tile.index] += 1;
                        }
                        currentPosition[blankTileIndex] = blankTilePosTemp;
                    } else {
                        console.log('push left');
                        for (let i = numMoveTiles; i > 0; i--) {
                            let tileObj = getTileAtPos(i + blankTilePos);
                            moveTiles.push(tileObj);
                            var tweenWithCallback1 = new Tween(tileObj.tile, "position.x", positions[i + blankTilePos - 1].x, tileTweenTime, true);
                            tweenWithCallback1.easing = Tween.outCubic;
                        }

                        let blankTilePosTemp;
                        for (let i = 0; i < moveTiles.length; i++) {
                            const tile = moveTiles[i];
                            if (i == 0) { blankTilePosTemp = currentPosition[tile.index]; } // first tile will be blank at last
                            currentPosition[tile.index] -= 1;
                        }
                        currentPosition[blankTileIndex] = blankTilePosTemp;
                    }
                }

                // same column
                if (tileRowCol[1] == blankRowCol[1]) {
                    var numMoveTiles = tileRowCol[0] - blankRowCol[0];
                    console.log('col numMoveTiles' + numMoveTiles);
                    var pushup = -1, pushdown = 1;
                    let dir = numMoveTiles < 0 ? pushdown : pushup;

                    let moveTiles = [];
                    if (dir == pushdown) {
                        console.log('push down');
                        numMoveTiles = -numMoveTiles;
                        for (let i = 0; i < numMoveTiles; i++) {
                            let tileObj = getTileAtPos(i * numCols + currentTilePos);
                            moveTiles.push(tileObj);
                            var tweenWithCallback1 = new Tween(tileObj.tile, "position.y", positions[i * numCols + currentTilePos + numCols].y, tileTweenTime, true);
                            tweenWithCallback1.easing = Tween.outCubic;
                        }

                        let blankTilePosTemp;
                        for (let i = 0; i < moveTiles.length; i++) {
                            const tile = moveTiles[i];
                            if (i == 0) { blankTilePosTemp = currentPosition[tile.index]; } // first tile will be blank at last
                            currentPosition[tile.index] += numCols;
                        }
                        currentPosition[blankTileIndex] = blankTilePosTemp;
                    } else {
                        console.log('push up');
                        for (let i = numMoveTiles; i > 0; i--) {
                            let tileObj = getTileAtPos(i * numCols + blankTilePos);
                            moveTiles.push(tileObj);
                            var tweenWithCallback1 = new Tween(tileObj.tile, "position.y", positions[i * numCols + blankTilePos - numCols].y, tileTweenTime, true);
                            tweenWithCallback1.easing = Tween.outCubic;
                        }

                        let blankTilePosTemp;
                        for (let i = 0; i < moveTiles.length; i++) {
                            const tile = moveTiles[i];
                            if (i == 0) { blankTilePosTemp = currentPosition[tile.index]; } // first tile will be blank at last
                            currentPosition[tile.index] -= numCols;
                        }
                        currentPosition[blankTileIndex] = blankTilePosTemp;
                    }
                }
            }

            function getTileAtPos(index) {
                for (let i = 0; i < numTiles; i++) {
                    if (currentPosition[i] == index) {
                        return { tile: tiles[i], index: i };
                    }
                }
            }

            function checkForGameWin() {
                var isGameWon = true;
                for (var i = 0; i < numTiles; i++) {
                    if (currentPosition[i] !== i) {
                        isGameWon = false;
                        break;
                    }
                }
                if (isGameWon) {
                    debugTextLog("Game Won. Cool");
                }
            }

            function onTweenComplete(param) {
                isTileMoving = false;

                //To Generate First Random Array
                /*var logText="";
                for(var i=0; i<currentPosition.length;i++)
                    logText += currentPosition[i]+",";
                console.log(logText);*/

                checkForGameWin();
            }

            function Point(x, y) {
                this.x = x;
                this.y = y;
            }

            debugTextLog("Game Start. Arrange the Tiles in Order.");

            for (var i = 0; i < numTiles; i++) {
                var tileHolder = new PIXI.Container();
                tileHolder.index = i;
                var newtile = PIXI.Sprite.fromImage('assets/tile.png');
                tile.anchor.set(0.5);

                var row = Math.floor(i / numCols);
                var col = Math.floor(i % numCols);
                tileHolder.x = tileStartX + col * tileWidth;
                tileHolder.y = tileStartY + row * tileWidth;

                var pt = new Point(tileHolder.x, tileHolder.y);
                positions.push(pt);

                currentPosition[i] = i;

                tileHolder.interactive = true;
                tileHolder.buttonMode = true;

                tileHolder.on('pointerdown', onTileClick);

                var richText = new PIXI.Text(i + 1, style);
                richText.x = 32;
                richText.y = 32;
                // center the text's anchor point
                richText.anchor.set(0.5);

                tileHolder.addChild(newtile);
                tileHolder.addChild(richText);

                tiles.push(tileHolder);

                if (i == (numTiles - 1)) {
                    tileHolder.visible = false;
                }

                app.stage.addChild(tileHolder);
            }

            //Set Initial Random Setup
            for (var i = 0; i < numTiles; i++) {
                currentPosition[i] = startPositions[i];

                var tilePos = startPositions[i];
                tiles[i].x = positions[tilePos].x;
                tiles[i].y = positions[tilePos].y;
            }

            // Listen for animate update
            app.ticker.add(function (delta) {
                Tween.runTweens();
            });
        }

        // pixi fullscreen ref
        // https://codepen.io/iamnotsam/pen/RgeOrK
        window.addEventListener("resize", function () {
            console.log('resize');
            app.renderer.resize(window.outerWidth, window.innerHeight);
            infoText.x = window.innerWidth / 2;
            infoText.y = window.innerHeight - 40;

            
            tileStartX = window.innerWidth / 2 - numCols / 2 * tileWidth;
            // set new positions
            for (var i = 0; i < numTiles; i++) {
                var row = Math.floor(i / numCols);
                var col = Math.floor(i % numCols);

                positions[i].x = tileStartX + col * tileWidth;
                positions[i].y = tileStartY + row * tileWidth;
            }

            for (var i = 0; i < numTiles; i++) {
                var tilePos = currentPosition[i];
                tiles[i].x = positions[tilePos].x;
                tiles[i].y = positions[tilePos].y;
            }
        });
    </script>
    <p id="debug" style="position: fixed; top: 20px; left: 20px;"> Debug Log </p>
</body>

</html>